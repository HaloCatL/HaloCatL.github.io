<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[奇怪的汉诺塔]]></title>
    <url>%2F2019%2F02%2F20%2F%E5%A5%87%E6%80%AA%E7%9A%84%E6%B1%89%E8%AF%BA%E5%A1%94%2F</url>
    <content type="text"><![CDATA[汉诺塔问题，条件如下： 1、这里有A、B、C和D四座塔。 2、这里有n个圆盘，n的数量是恒定的。 3、每个圆盘的尺寸都不相同。 4、所有的圆盘在开始时都堆叠在塔A上，且圆盘尺寸从塔顶到塔底逐渐增大。 5、我们需要将所有的圆盘都从塔A转移到塔D上。 6、每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。 请你求出将所有圆盘从塔A移动到塔D，所需的最小移动次数是多少。 汉诺塔塔参考模型 输入格式没有输入 输出格式对于每一个整数n($1≤n≤12$),输出一个满足条件的最小移动次数，每个结果占一行。 输入样例：1没有输入 输出样例：1参考输出格式 题目题解经典的递推题，我们设d为三个塔的情况，f为四个塔的情况。 我们d的推导公式是 $d_i = d_{i - 1} * 2 + 1$ 推导方式：若当前我们有三个塔，第一个塔有5个，我们将上面的4个移动到第二个需要花费K次移动的话，那么我们再将最大的一个移动最后一个，我们再将第二个叠到第三个 需要花费K + 1次移动，总共就是K*2 + 1次移动。 因为每次我们的n都是累加的，所以我们可以反复利用d数组 分析完三个塔，我们再来分析四个塔 推导方式：若当前我们有四个塔，那么移动总数一定小于三个，因为多了一个塔，我们可以将之前第二个塔的盘子的数量减少，这减少的部分就直接移动到最后一个塔，而第三个塔的盘子仍旧放到第四个塔不动， 然后这样到最后的结果一定变少。（自己画图理解一下）那么推导公式是 $f_i = min(f_i, f_j + d_{i - j})$ 这里的$j$就是枚举的分出去的量，这个量可能 $=0$ 但永远不可能$≥i$ 为什么是$d_{i - j}$，因为将上面的移动完之后，下面的只用移动一次到最后一个塔就行。 于是我们就可以得到代码： 123456789101112131415161718192021222324252627//#define fre yes#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;const int N = 15;int d[N], f[N];int main() &#123; d[1] = 1; //初始化，如果n = 1的话 移动次数为1 for (int i = 2; i &lt;= 12; i++) &#123; d[i] = d[i - 1] * 2 + 1; //转移方程 &#125; memset(f, 0x3f, sizeof(f)); //因为求最小值，所以讲数组重定为最大 f[0] = 0; //n为0时，f为0 for (int i = 1; i &lt;= 12; i++) &#123; //12次n for (int j = 0; j &lt; i; j++) &#123; //枚举j 分几个走 f[i] = std::min(f[i], f[j] * 2 + d[i - j]); //转移方程 &#125; &#125; for (int i = 1; i &lt;= 12; i++) &#123; printf("%d\n", f[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费解的开关]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3%2F</url>
    <content type="text"><![CDATA[你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态 123451011101101101111000011011 在改变了最左上角的灯的状态后将变成： 123450111111101101111000011011 再改变它正中间的灯后状态将变成： 123450111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。 输入格式第一行输入正整数$n$，代表数据中共有$n$个待解决的游戏初始状态。 以下若干行数据分为$n$组，每组数据有$5$行，每行$5$个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。 输出格式一共输出$n$行数据，每行有一个小于等于$6$的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。 对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。 数据范围$0&lt;n≤500$ 输入样例：1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 输出样例：12332-1 题目题解对于这个题，其实在2017年有一道初赛题和这个很像 对于这个题，我们如果考虑第一行的所有情况，就相当于确定了整个棋盘的所有情况 因为一个数如果想要改变，并且不会修改之前修改的情况的话，一定是修改当前数的下一行的同列数。 那么我们只需枚举第一行的所有情况即可。 那么根据第一行的枚举情况我们向下推就好。 详细看代码注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//#define fre yes#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;const int N = 15;char path[N][N];const int INF = 1e9;int dx[] = &#123;0, -1, 0, 1, 0&#125;; //向4个方向移动int dy[] = &#123;0, 0, 1, 0, -1&#125;;void turn(int x, int y) &#123; for (int i = 0; i &lt; 5; i++) &#123; int a = x + dx[i], b = y + dy[i]; if(a &gt;= 0 &amp;&amp; a &lt; 5 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 5) &#123; path[a][b] ^= 1; //这里的意思是将path[a][b]换成ASCII上的二进制数然后异或完之后再换回去 这样'1' ^ 1 = '0' '0' ^ 1 = '1' &#125; &#125;&#125;int work() &#123; int ans = INF; for (int k = 0; k &lt; 1 &lt;&lt; 5; k++) &#123; //枚举第一排的所有情况 用二进制数表示 char backup[N][N]; int res = 0; memcpy(backup, path, sizeof path); //复制整个path数组到backup for (int j = 0; j &lt; 5; j++) &#123; //枚举第一排的所有情况 if(k &gt;&gt; j &amp; 1) &#123; res++; turn(0, j); &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; if(path[i][j] == '0') &#123; res++; turn(i + 1, j); &#125; &#125; &#125; bool is_successful = true; for (int j = 0; j &lt; 5; j++) &#123; if(path[4][j] == '0') &#123; is_successful = false; break; &#125; &#125; if(is_successful) ans = std::min(ans, res); mempcpy(path, backup, sizeof backup); //将path替换到backup &#125; if(ans &gt; 6) ans = -1; //记得步数不能超过6 return ans;&#125;int main() &#123; static int T; scanf("%d", &amp;T); while(T--) &#123; for (int i = 0; i &lt; 5; i++) scanf("%s", path[i]); printf("%d\n", work()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归实现排列型枚举]]></title>
    <url>%2F2019%2F02%2F18%2F%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[把 $1~n$ 这 $n$ 个整数排成一行后随机打乱顺序，输出所有可能的次序。 输入格式一个整数$n$。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。 数据范围$1≤n≤9$ 输入样例：13 输出样例：1234561 2 31 3 22 1 32 3 13 1 23 2 1 题目题解相比于递归实现指数型枚举与递归实现组合型枚举，这道题需要输出次序，因为我们的二进制只能表示某一位是否用过，并不能储存位置，所以我们需要使用数组的帮助。 详细看代码 123456789101112131415161718192021222324252627282930//#define fre yes#include &lt;cstdio&gt;#include &lt;vector&gt;int n;std::vector&lt;int&gt; path; //vector数组void dfs(int u, int state) &#123; if(u == n) &#123; for (int i = 0; i &lt; path.size(); i++) &#123; printf("%d ", path[i]); &#125; puts(""); return ; &#125; for (int i = 0; i &lt; n; i++) &#123; if(!(state &gt;&gt; i &amp; 1)) &#123; path.push_back(i + 1); dfs(u + 1, state | (1 &lt;&lt; i)); //不需要讨论不选，因为所有数必须选 path.pop_back(); //递归回来记得清理足迹 &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;n); dfs(0, 0); return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归实现组合型枚举]]></title>
    <url>%2F2019%2F02%2F18%2F%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[从 $1~n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。 输入格式两个整数 $n,m$ ,在同一行用空格隔开。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。 数据范围$n&gt;0$,$0≤m≤n$ ,$n+(n−m)≤25$ 输入样例：15 3 输出样例：123456789101 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5 题目题解相比于递归实现指数型枚举这道题多了一个数量限制，我们仅仅只需要将代码改一改就好了 12345678910111213141516171819202122232425262728//#define fre yes#include &lt;cstdio&gt;int n, m;void dfs(int u, int sum, int state) &#123; if(sum + n - u &lt; m) return ; //增加一个优化 （这里可以删除） if(sum == m) &#123; for (int i = 0; i &lt; n; i++) &#123; if(state &gt;&gt; i &amp; 1) &#123; printf("%d ", i + 1); &#125; &#125; puts(""); return ; &#125; if(u == n) return ; dfs(u + 1, sum + 1, state | (1 &lt;&lt; u)); //因为我们要从小到大 所以我们要先选 dfs(u + 1, sum, state); //或者不选&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;m); dfs(0, 0, 0); return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归实现指数型枚举]]></title>
    <url>%2F2019%2F02%2F18%2F%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。 输入格式输入一个整数$n$。 输出格式每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。 数据范围$1≤n≤15$ 输入样例：13 输出样例：1234567322 311 31 21 2 3 题目题解递归基础模板题 详细看代码 12345678910111213141516171819202122232425//#define fre yes#include &lt;cstdio&gt;int n;void dfs(int u, int state) &#123; //第一个表示搜到第几了，第二个表示一个二进制数表示 哪些数用过 if(u == n) &#123; //如果遍历到第n个数了那么我们就输出即可 for (int i = 0; i &lt; n; i++) &#123; if(state &gt;&gt; i &amp; 1) &#123; //第i个数如果用过， printf("%d ", i + 1); //输出i &#125; &#125; puts(""); return ; &#125; dfs(u + 1, state); //不选第u个数 dfs(u + 1, state | 1 &lt;&lt; u);//选第u个数&#125;int main() &#123; scanf("%d", &amp;n); dfs(0, 0); return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短Hamilton路径]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[给定一张 $n$ 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。 输入格式第一行输入整数$n$。 接下来$n$行每行$n$个整数，其中第$i$行第$j$个整数表示点$i$到$j$的距离（记为a[i,j]）。 对于任意的$x,y,z$，数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]&gt;=a[x,z]。 输出格式输出一个整数，表示最短Hamilton路径的长度。 数据范围$1≤n≤20$$0≤a[i,j]≤10^7$ 输入样例：12345650 2 4 5 12 0 6 5 34 6 0 8 35 5 8 0 51 3 3 5 0 输出样例：118 题目题解Hamilton路径是一种经典的NP问题，这种问题没有一个有效的多项式进行优化 所以我们可以考虑爆搜，并使用位运算进行计算优化 首先，如果使用爆搜，我们就得遍历所有的可能 这个时间复杂度是 O(20!) 那么就是 2432902008176640000 这么多的时间复杂度 所以我们可以排除爆搜这种做法，那么我们就考虑其他的想法 因为我们要走完所有的路，并且走最短路 我们考虑两种走法 （若此时我们有 $i$ $j$ $k$ 三个点 1：$i$ ——&gt; $j$ 2：$i$ ——&gt; $k$ ——&gt; $j$ 若第二种的路径长度小于第一种，说明我们走下面是最优的，我们 i -&gt; j 的长度就可以变成最优的那个 于是我们就可以推出关系式 $f_{i,j} = min(f_{i,j}, f_{i - (1 &lt;&lt; j),k} + weight_{k,j})$ 这里的 $i$ 储存的是我们所有点的状态（二进制数），$j$ 表达的是第 $j$ 个点 $k$ 表达的是第 $k$ 个点 （$i$如果是 7[111] 那么 就表示第一、二、三个点都是用过的） 这里的 $i - (1 &lt;&lt; j)$ 就是当前状态是由上一个第$j$个点没有遍历过的状态转移过来的 于是根据上方关系，我们就可以列出代码 12345678910111213141516171819202122232425262728293031323334353637//#define fre yes#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;const int N = 1 &lt;&lt; 20, M = 25;int f[N][M], weight[M][M];int main() &#123; static int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; scanf("%d", &amp;weight[i][j]); &#125; &#125; memset(f, 0x3f, sizeof(f)); //因为求最小值，我们需要先将路程转为最大值 f[1][0] = 0; for (int i = 0; i &lt; 1 &lt;&lt; n; i++) &#123; //枚举所有状态 for (int j = 0; j &lt; n; j++) &#123; //枚举所有点 if(i &gt;&gt; j &amp; 1) &#123; //如果第j个点遍历过了 for (int k = 0; k &lt; n; k++) &#123; //枚举第k个点 if(i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) &#123; //如果在状态中减去j之后第k个点依旧遍历到了 f[i][j] = std::min(f[i][j], f[i - (1 &lt;&lt; j)][k] + weight[k][j]); //进行转移方程 &#125; &#125; &#125; &#125; &#125; printf("%d\n", f[(1 &lt;&lt; n) - 1][n - 1]); //因为我们是从0开始记位，所以我们都要-1 return 0;&#125; 注意 这里的$f_{i,j}$并不是代表的 $i$ 点到 $j$ 点，而是当前已经到达 $j$ 点时所有点的状态，以及当前走过的最短路径！！]]></content>
      <categories>
        <category>位运算</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[64位整数乘法]]></title>
    <url>%2F2019%2F02%2F17%2F64%E4%BD%8D%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[求 $a$ 乘 $b$ 对 $p$ 取模的值。 输入格式第一行输入整数$a$，第二行输入整数$b$，第三行输入整数$p$。 输出格式输出一个整数，表示$a*b Mod p$的值。 数据范围$1≤a,b,p≤10^{18}$ 输入样例：13 4 5 输出样例：12 题目题解推导式子等同于 快速幂 只需稍微修改即可，详细看代码 12345678910111213141516//#define fre yes#include &lt;cstdio&gt;int main() &#123; long long a, b, c; scanf("%lld %lld %lld", &amp;a, &amp;b, &amp;c); long long res = 0; while(b) &#123; if(b &amp; 1) res = (res + a) % c; a = (a + a) % c; b &gt;&gt;= 1; &#125; printf("%lld\n", res); return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
        <category>快速幂</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[求 $a$ 的 $b$ 次方对 $p$ 取模的值。 输入格式三个整数 $a,b,p$ ,在同一行用空格隔开。 输出格式输出一个整数，表示a^b mod p的值。 数据范围$1≤a,b,p≤10^9$ 输入样例：13 2 7 输出样例：12 题目题解若要直接算 $a^b$ 即计算 $b$ 遍，复杂度就是 $O(n)$ 快速幂的时间复杂度可以将原本 $O(n)$ 的时间复杂度缩短为 $O(logn)$ 基本思想： 原式若为 $a^{10}$ 那么 原式 = $a ^ {((2 × 1) + (2 × 3))}$ = $a ^ {(2 × 1)} + a ^ {(2 × 3)}$ 为什么将 10 分为关于 2 的式子？ 因为可以将其联系到二进制数 根据二进制数我们可以利用二进数的特点将其的计算量大幅度减少 于是我们可以得出以下代码… 123456789101112131415//#define fre yes#include &lt;cstdio&gt;int main() &#123; static int a, b, p; scanf("%d %d %d", &amp;a, &amp;b, &amp;p); int res = 1 % p; //若 b = 0 p = 1 那么下面计算就不会进行 最后结果不会计算 所以需要%一个 while(b) &#123; if(b &amp; 1) res = (long long)res * a % p; // 中途数据会超long long这里需要转换 a = (long long)a * a % p; b &gt;&gt;= 1; &#125; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
        <category>快速幂</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[2019年2月12日，你好，世界！]]></content>
  </entry>
</search>
