<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[递归实现排列型枚举]]></title>
    <url>%2F2019%2F02%2F18%2F%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[把 $1~n$ 这 $n$ 个整数排成一行后随机打乱顺序，输出所有可能的次序。 输入格式一个整数$n$。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。 数据范围$1≤n≤9$ 输入样例：13 输出样例：1234561 2 31 3 22 1 32 3 13 1 23 2 1 题目题解相比于递归实现指数型枚举与递归实现组合型枚举，这道题需要输出次序，因为我们的二进制只能表示某一位是否用过，并不能储存位置，所以我们需要使用数组的帮助。 详细看代码 123456789101112131415161718192021222324252627282930//#define fre yes#include &lt;cstdio&gt;#include &lt;vector&gt;int n;std::vector&lt;int&gt; path; //vector数组void dfs(int u, int state) &#123; if(u == n) &#123; for (int i = 0; i &lt; path.size(); i++) &#123; printf("%d ", path[i]); &#125; puts(""); return ; &#125; for (int i = 0; i &lt; n; i++) &#123; if(!(state &gt;&gt; i &amp; 1)) &#123; path.push_back(i + 1); dfs(u + 1, state | (1 &lt;&lt; i)); //不需要讨论不选，因为所有数必须选 path.pop_back(); //递归回来记得清理足迹 &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;n); dfs(0, 0); return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归实现组合型枚举]]></title>
    <url>%2F2019%2F02%2F18%2F%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[从 $1~n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。 输入格式两个整数 $n,m$ ,在同一行用空格隔开。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。 数据范围$n&gt;0$,$0≤m≤n$ ,$n+(n−m)≤25$ 输入样例：15 3 输出样例：123456789101 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5 题目题解相比于递归实现指数型枚举这道题多了一个数量限制，我们仅仅只需要将代码改一改就好了 12345678910111213141516171819202122232425262728//#define fre yes#include &lt;cstdio&gt;int n, m;void dfs(int u, int sum, int state) &#123; if(sum + n - u &lt; m) return ; //增加一个优化 （这里可以删除） if(sum == m) &#123; for (int i = 0; i &lt; n; i++) &#123; if(state &gt;&gt; i &amp; 1) &#123; printf("%d ", i + 1); &#125; &#125; puts(""); return ; &#125; if(u == n) return ; dfs(u + 1, sum + 1, state | (1 &lt;&lt; u)); //因为我们要从小到大 所以我们要先选 dfs(u + 1, sum, state); //或者不选&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;m); dfs(0, 0, 0); return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归实现指数型枚举]]></title>
    <url>%2F2019%2F02%2F18%2F%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。 输入格式输入一个整数$n$。 输出格式每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。 数据范围$1≤n≤15$ 输入样例：13 输出样例：1234567322 311 31 21 2 3 题目题解递归基础模板题 详细看代码 12345678910111213141516171819202122232425//#define fre yes#include &lt;cstdio&gt;int n;void dfs(int u, int state) &#123; //第一个表示搜到第几了，第二个表示一个二进制数表示 哪些数用过 if(u == n) &#123; //如果遍历到第n个数了那么我们就输出即可 for (int i = 0; i &lt; n; i++) &#123; if(state &gt;&gt; i &amp; 1) &#123; //第i个数如果用过， printf("%d ", i + 1); //输出i &#125; &#125; puts(""); return ; &#125; dfs(u + 1, state); //不选第u个数 dfs(u + 1, state | 1 &lt;&lt; u);//选第u个数&#125;int main() &#123; scanf("%d", &amp;n); dfs(0, 0); return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短Hamilton路径]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[给定一张 $n$ 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。 输入格式第一行输入整数$n$。 接下来$n$行每行$n$个整数，其中第$i$行第$j$个整数表示点$i$到$j$的距离（记为a[i,j]）。 对于任意的$x,y,z$，数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]&gt;=a[x,z]。 输出格式输出一个整数，表示最短Hamilton路径的长度。 数据范围$1≤n≤20$$0≤a[i,j]≤10^7$ 输入样例：12345650 2 4 5 12 0 6 5 34 6 0 8 35 5 8 0 51 3 3 5 0 输出样例：118 题目题解Hamilton路径是一种经典的NP问题，这种问题没有一个有效的多项式进行优化 所以我们可以考虑爆搜，并使用位运算进行计算优化 首先，如果使用爆搜，我们就得遍历所有的可能 这个时间复杂度是 O(20!) 那么就是 2432902008176640000 这么多的时间复杂度 所以我们可以排除爆搜这种做法，那么我们就考虑其他的想法 因为我们要走完所有的路，并且走最短路 我们考虑两种走法 （若此时我们有 $i$ $j$ $k$ 三个点 1：$i$ ——&gt; $j$ 2：$i$ ——&gt; $k$ ——&gt; $j$ 若第二种的路径长度小于第一种，说明我们走下面是最优的，我们 i -&gt; j 的长度就可以变成最优的那个 于是我们就可以推出关系式 $f_{i,j} = min(f_{i,j}, f_{i - (1 &lt;&lt; j),k} + weight_{k,j})$ 这里的 $i$ 储存的是我们所有点的状态（二进制数），$j$ 表达的是第 $j$ 个点 $k$ 表达的是第 $k$ 个点 （$i$如果是 7[111] 那么 就表示第一、二、三个点都是用过的） 这里的 $i - (1 &lt;&lt; j)$ 就是当前状态是由上一个第$j$个点没有遍历过的状态转移过来的 于是根据上方关系，我们就可以列出代码 12345678910111213141516171819202122232425262728293031323334353637//#define fre yes#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;const int N = 1 &lt;&lt; 20, M = 25;int f[N][M], weight[M][M];int main() &#123; static int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; scanf("%d", &amp;weight[i][j]); &#125; &#125; memset(f, 0x3f, sizeof(f)); //因为求最小值，我们需要先将路程转为最大值 f[1][0] = 0; for (int i = 0; i &lt; 1 &lt;&lt; n; i++) &#123; //枚举所有状态 for (int j = 0; j &lt; n; j++) &#123; //枚举所有点 if(i &gt;&gt; j &amp; 1) &#123; //如果第j个点遍历过了 for (int k = 0; k &lt; n; k++) &#123; //枚举第k个点 if(i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) &#123; //如果在状态中减去j之后第k个点依旧遍历到了 f[i][j] = std::min(f[i][j], f[i - (1 &lt;&lt; j)][k] + weight[k][j]); //进行转移方程 &#125; &#125; &#125; &#125; &#125; printf("%d\n", f[(1 &lt;&lt; n) - 1][n - 1]); //因为我们是从0开始记位，所以我们都要-1 return 0;&#125; 注意 这里的$f_{i,j}$并不是代表的 $i$ 点到 $j$ 点，而是当前已经到达 $j$ 点时所有点的状态，以及当前走过的最短路径！！]]></content>
      <categories>
        <category>位运算</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[64位整数乘法]]></title>
    <url>%2F2019%2F02%2F17%2F64%E4%BD%8D%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[求 $a$ 乘 $b$ 对 $p$ 取模的值。 输入格式第一行输入整数$a$，第二行输入整数$b$，第三行输入整数$p$。 输出格式输出一个整数，表示$a*b Mod p$的值。 数据范围$1≤a,b,p≤10^{18}$ 输入样例：13 4 5 输出样例：12 题目题解推导式子等同于 快速幂 只需稍微修改即可，详细看代码 12345678910111213141516//#define fre yes#include &lt;cstdio&gt;int main() &#123; long long a, b, c; scanf("%lld %lld %lld", &amp;a, &amp;b, &amp;c); long long res = 0; while(b) &#123; if(b &amp; 1) res = (res + a) % c; a = (a + a) % c; b &gt;&gt;= 1; &#125; printf("%lld\n", res); return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
        <category>快速幂</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[求 $a$ 的 $b$ 次方对 $p$ 取模的值。 输入格式三个整数 $a,b,p$ ,在同一行用空格隔开。 输出格式输出一个整数，表示a^b mod p的值。 数据范围$1≤a,b,p≤10^9$ 输入样例：13 2 7 输出样例：12 题目题解若要直接算 $a^b$ 即计算 $b$ 遍，复杂度就是 $O(n)$ 快速幂的时间复杂度可以将原本 $O(n)$ 的时间复杂度缩短为 $O(logn)$ 基本思想： 原式若为 $a^{10}$ 那么 原式 = $a ^ {((2 × 1) + (2 × 3))}$ = $a ^ {(2 × 1)} + a ^ {(2 × 3)}$ 为什么将 10 分为关于 2 的式子？ 因为可以将其联系到二进制数 根据二进制数我们可以利用二进数的特点将其的计算量大幅度减少 于是我们可以得出以下代码… 123456789101112131415//#define fre yes#include &lt;cstdio&gt;int main() &#123; static int a, b, p; scanf("%d %d %d", &amp;a, &amp;b, &amp;p); int res = 1 % p; //若 b = 0 p = 1 那么下面计算就不会进行 最后结果不会计算 所以需要%一个 while(b) &#123; if(b &amp; 1) res = (long long)res * a % p; // 中途数据会超long long这里需要转换 a = (long long)a * a % p; b &gt;&gt;= 1; &#125; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
        <category>快速幂</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[2019年2月12日，你好，世界！]]></content>
  </entry>
</search>
