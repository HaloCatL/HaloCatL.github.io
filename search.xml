<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[19年3月21日 竞赛小测]]></title>
    <url>%2F2019%2F03%2F21%2F19%E5%B9%B43%E6%9C%8821%E6%97%A5-%E7%AB%9E%E8%B5%9B%E5%B0%8F%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[rank1 200 T1 100 T2 100 T3 0 1 、 山峰和山谷(grz.cpp/1s/256M)【问题描述】Byteasar 特别喜欢爬山，在爬山的时候他就在研究山峰和山谷。为了能够让他对他的旅程有一个安排，他想知道山峰和山谷的数量。 给定一个地图， 为 Byteasar 想要旅行的区域， 地图被分为 $n×n$ 的网格， 每个格子$(i,j)$ 的高度 $w(i,j)$是给定的。 若两个格子有公共顶点，那么他们就是相邻的格子。 （所以与(i,j)相邻的格子有(i−1,j−1),(i−1,j),(i−1,j+1),(i,j−1),(i,j+1),(i+1,j−1),(i+1,j),(i+1,j+1)） 。 我们定义一个格子的集合 $S$ 为山峰（山谷）当且仅当：1.$S$ 的所有格子都有相同的高度。2.$S$ 的所有格子都联通3.对于$s$属于$S$，与$s$相邻的$s’$不属于$S$。都有$ws&gt;ws’$（山峰） ，或者$ws&lt;ws’$（山谷）。 你的任务是，对于给定的地图，求出山峰和山谷的数量，如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。 【输入格式】输入文件 grz.in 第一行包含一个正整数 $n$，表示地图的大小（1&lt;=n&lt;=1000） 。接下来一个 $n×n$ 的矩阵，表示地图上每个格子的高度。(0&lt;=w&lt;=1000000000) 【输出格式】输出文件 grz.out 应包含两个数，分别表示山峰和山谷的数量。grz .in grz.out 【输入样例】12345658 8 8 7 77 7 8 8 77 7 7 7 77 8 8 7 87 8 8 8 8 【输出样例】12 1 【输入样例】12345655 7 8 3 15 5 7 6 66 6 6 2 85 7 2 5 87 1 0 1 7 【输出样例】13 3 【数据范围】$1&lt;=n&lt;=1000$$0&lt;=w&lt;=1000000000$ 【题目题解】题目读了很久没读懂，最后同学解释了一下，突然就明白了 感谢@wz 题目：给你一个$n×n$的格子，每个格子上有一个数字，如果当前数字的8个方向有相同的数字，那么他们就归为一个集合，一个集合内的每一个数的八个方向，如果有与之不相同的数，如果这个数比集合里的数大，那么集合就归为山谷，如果这个数比集合小，那么这个集合就归为山峰。 其中需要注意的是，如果有两种数存在，即既存在比它小又存在比它大的数的话，那么这种就是违规的询问，不用管它就好。还有个条件需要注意，文章中已经加粗！ 除了我，都写的bfs，然后都0分…. 还是深搜大法好！ 裸深搜，详细看代码！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#define fre yes#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N = 1005;int f[N][N];bool Vis[N][N];int dx[] = &#123;0, 0, 1, -1, 1, -1, 1, -1&#125;; //向8个方向移动int dy[] = &#123;1, -1, 0, 0, 1, -1, -1, 1&#125;;int n;bool legal(int x, int y) &#123; //判断是否在界内 if(x &gt;= 1 &amp;&amp; y &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &lt;= n) return true; return false;&#125;bool flag_1, flag_2;void dfs(int x, int y) &#123; for (int i = 0; i &lt; 8; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if(legal(nx, ny)) &#123; if(f[nx][ny] &gt; f[x][y]) flag_1 = true; else if(f[nx][ny] &lt; f[x][y]) flag_2 = true; else if(f[nx][ny] == f[x][y] &amp;&amp; !Vis[nx][ny]) &#123; Vis[nx][ny] = 1; dfs(nx, ny); //因为我们递归的时候跑不完，所以我们回溯再循环一遍防止没跑完 for (int j = i - 1; j &lt; 8; j++) &#123; int wx = x + dx[j]; int wy = y + dy[j]; if(legal(wx, wy)) &#123; if(f[wx][wy] &gt; f[x][y]) flag_1 = true; else if(f[wx][wy] &lt; f[x][y]) flag_2 = true; &#125; &#125; &#125; &#125; &#125;&#125;int main() &#123;#ifdef fre freopen("grz.in", "r", stdin); freopen("grz.out", "w", stdout);#endif static int right, down; scanf("%d", &amp;n); int res = 0; //res记录这个图内是不是都是相同的 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;f[i][j]); if(j == 1 &amp;&amp; i != 1 &amp;&amp; f[i - 1][n] == f[i][j]) res++; if(j != 1 &amp;&amp; f[i][j - 1] == f[i][j]) res++; &#125; &#125; if(f[n][n] == f[n][n - 1]) res++; if(res == n * n) &#123; //如果是 那就输出1 1 puts("1 1"); return 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; //开始一个点一个点的深搜 for (int j = 1; j &lt;= n; j++) &#123; if(!Vis[i][j]) &#123; flag_1 = false, flag_2 = false; //比集合小的 和 比集合大的都不存在 Vis[i][j] = 1; dfs(i, j); if(flag_1 &amp;&amp; flag_2) continue; //两个都存在那么就是违法的 if(flag_1) down++; if(flag_2) right++; &#125; &#125; &#125; printf("%d %d\n", right, down); return 0;&#125; 2 、 路由器安置(Routing.cpp/1s/64M)【问题描述】一条街道安装无线网络，需要放置 M 个路由器。整条街道上一共有 N 户居民，分布在一条直线上，每一户居民必须被至少一台路由器覆盖到。现在的问题是所有路由器的覆盖半径是一样的，我们希望用覆盖半径尽可能小的路由器来完成任务，因为这样可以节省成本。 【输入格式】输入文件第一行包含两个整数 $M$ 和 $N$，以下 $N$ 行每行一个整数 $H_i$ 表示该户居民在街道上相对于某个点的坐标。 【输出格式】输出文件仅包含一个数，表示最小的覆盖半径，保留一位小数。 Routing.in Routing.out 【样例输入】1234532 31310 【样例输出】11.0 （在 2，10 位置上各放一个） 【数据约定】对于 60%的数据，有 $1 ≤ N, M ≤ 100，-1000 ≤ H_i ≤ 1000$；对于 100%的数据，有 $1 ≤ N, M ≤ 100000，-10000000 ≤ H_i ≤ 10000000$。 【题目题解】二分裸题，贪心这种根本没想..，每次二分枚举半径的大小，在check函数里贪心一下就好了。 详细的看代码.. （话说10分钟就搞定了,,,,） 感谢@北大-yxc老师 的二分辅导 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define fre yes#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N = 100005;int a[N];int n, m, minn, maxx;bool check(double x) &#123; int num = 0; double location = 0.0; for (int i = 1; i &lt;= m; i++) &#123; if(location &gt;= maxx) &#123; break; &#125; if(i == 1) &#123; //我们最优的位置一定是放到最大范围上，这样就能贡献更多的范围 location = a[i] + 2 * x; num++; &#125; else if(i != 1 &amp;&amp; a[i] &lt; location) continue; else if(i != 1 &amp;&amp; a[i] &gt; location) &#123; location = a[i] + 2 * x; num++; &#125; &#125; if(location &gt;= maxx) &#123; //如果当前已经大于我们的位置最大值就可以停止了 if(num &lt;= n) return true; else return false; &#125;&#125;int main() &#123;#ifdef fre freopen("Routing.in", "r", stdin); freopen("Routing.out", "w", stdout);#endif scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d", &amp;a[i]); &#125; std::sort(a + 1, a + 1 + m); minn = a[1]; maxx = a[m]; double l = 0, r = 10000000; //最大最小值 while(r - l &gt; 1e-5) &#123; //开始二分 double mid = (l + r) / 2; if(check(mid)) r = mid; else l = mid; &#125; printf("%.1lf\n", l); return 0;&#125; 3 、 这不是 Floyd (AntiFloyd /1s/128M)【问题描述】传说中有一种神奇的算法叫做 Floyd，它竟然能算出一张有向图的传递闭包！ （传递闭包是一张记录表，记录了每个点对之间是否连通。 ）但是现在出现了一个难题，国王想要建立一个特殊的省供 OIER 生活，省内包含许多城市，国王得到一份“传递闭包” ，就是一个 N*N 的 01 矩阵，第 I 行第 J 列表示城市 I 到城市 J 之间是否有需求通讯（0 是不需求，1 是需求） 。如果城市 A 想与城市 B 之间通讯，则需要建立一条光缆（由于国王手下的废材工程员，光缆竟然是单向的，如果有一条光缆从 A 到 B，则 A 可以发讯息到 B，但是 B 不能发讯息到 A） 。光缆是具有连续性的，比如说 A 有条光缆到 B，B 有条光缆到 C，则 A 可以发送讯息到 C，所以国王拿到的那份“传递闭包”中，不可能出现 A-&gt;B，B-&gt;C 但是 A 不能到 C 这种情况。由于经费问题，所以国王想要用最少的光缆完成城市信息网的建立，然而手下的那群好吃懒做的程序员啊，国王很头疼，所以请到了传说中的哥！要求解决这个问题。 【输入格式】输入文件 antifloyd.in，第一行包括一个个整数 $N$。以下 $N$ 行 $N$ 列的 01 矩阵，含义如描述。 【输出格式】输出文件 antifloyd.out，仅包括一行就是最少需要多少条光缆。 【样例输入】123431 1 11 1 11 1 1 【样例输出】13 【数据范畴】对于 100%的数据，$0≤N≤200$； 【题目题解】前排感谢 @RoS ♪DarkScoCu dalao的帮助 这道题先把所有的需求连单向边缩点，缩完点之后的新图剩下的边跑floyd，把不必要的边砍掉，对于环中环这种图，我们在缩点的时候就已经解决掉了。 现场没想到缩点，以为是dfs跑环.. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#define fre yes#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;class Graphics&#123; const static int MAXN = 205; const static int MAXM = 205*205;private: struct Edge&#123; int to, next; &#125;edge[MAXM]; struct Point&#123; int dfn, low, color; &#125;point[MAXN]; int sign, dfnNum, colorNum, sumOfPoint, first[MAXN], count[MAXN]; int path[MAXN][MAXN]; bool need[MAXN][MAXN]; vector&lt;pair&lt;int, int&gt; &gt; tmp; bool vis[MAXN]; stack&lt;int&gt; stk; void tarjan(int u)&#123; point[u].dfn = ++dfnNum; point[u].low = dfnNum; vis[u] = true; stk.push(u); for(int i = first[u]; i != -1; i = edge[i].next)&#123; int to = edge[i].to; if(!point[to].dfn)&#123; tarjan(to); point[u].low = min(point[to].low, point[u].low); &#125;else if(vis[to])&#123; point[u].low = min(point[to].dfn, point[u].low); &#125; &#125; if(point[u].dfn == point[u].low)&#123; vis[u] = false; point[u].color = ++colorNum; count[colorNum] ++; while(stk.top() != u)&#123; vis[stk.top()] = false; point[stk.top()].color = colorNum; count[colorNum] ++; stk.pop(); &#125; stk.pop(); &#125; &#125;public: void clear(int n)&#123; sign = dfnNum = colorNum = 0; for(int i = 1; i &lt;= n; i ++)&#123; first[i] = -1; vis[i] = 0; count[i] = 0; &#125; for(int i = 1; i &lt;= n; i ++)&#123; for(int j = 1; j &lt;= n; j ++)&#123; need[i][j] = false; path[i][j] = false; &#125; &#125; sumOfPoint = n; while(!stk.empty()) stk.pop(); tmp.clear(); &#125; void addEdgeOneWay(int u, int v)&#123; edge[sign].to = v; edge[sign].next = first[u]; need[u][v] = true; first[u] = sign ++; &#125; void addEdgeTwoWay(int u, int v)&#123; addEdgeOneWay(u, v); addEdgeOneWay(v, u); &#125; void tarjanAllPoint()&#123; for(int i = 1; i &lt;= sumOfPoint; i ++)&#123; if(!point[i].dfn) tarjan(i); &#125; &#125; int getAns()&#123; int ans = 0; tarjanAllPoint(); /** 所有环需要添加的边数为点数。 把缩成一个点包含的所有点连成一个圈 比如有 1 2 3 就连成 1-&gt;2-&gt;3-&gt;1 只有一个点的不用连边，特判掉 **/ for(int i = 1; i &lt;= colorNum; i ++)&#123; if(count[i] != 1)&#123; ans += count[i]; &#125; &#125; /** ans 为需要添加的边的数量 k为中间点（不一定只有一个） i 和 j 分别代表 颜色为i的所有点 和 颜色为j的所有点 缩点后的新图重新构图 直接先把所有需求边加上 i -&gt; j 的所有走法 tmp用来存所有需要加的边 颜色为i的点 -&gt; 颜色为j的点 最后用来处理掉不必要的边 **/ for(int i = 1; i &lt;= sumOfPoint; i ++)&#123; for(int j = 1; j &lt;= sumOfPoint; j ++)&#123; if(need[i][j] &amp;&amp; point[i].color != point[j].color)&#123; ans ++; tmp.push_back(make_pair(point[i].color, point[j].color)); path[point[i].color][point[j].color] ++; &#125; &#125; &#125; /** path[i][j] 代表 颜色为i的点 到 颜色为j的点 有 多少种走法 跑floyd 如果可以从 i -&gt; k -&gt; j 则多出 path[i][k] * path[k][j] 种走法 **/ for(int k = 1; k &lt;= colorNum; k ++)&#123; for(int i = 1; i &lt;= colorNum; i ++)&#123; for(int j = 1; j &lt;= colorNum; j ++)&#123; if(path[i][k] &amp;&amp; path[k][j])&#123; path[i][j] += path[i][k] * path[k][j]; &#125; &#125; &#125; &#125; /** ans 为需要添加的边的数量 k为中间点（不一定只有一个） i 和 j 分别代表 颜色为i的所有点 和 颜色为j的所有点 因为初始添加了所有的边 i-&gt;j path[i][j] = i-&gt;j的所有走法 + i-&gt;k-&gt;j 的所有走法 这时候逐个删去 i-&gt;j 的走法 每删去一条 ans -- （只要留一条即可） 如果存在i-&gt;k-&gt;j 当所有走法删去后 path[i][j] = i-&gt;k-&gt;j的所有走法 ans -= i-&gt;j的所有走法 如果不存在i-&gt;k-&gt;j 则当删去所有走法后 path[i][j] = 0 （ans -= （i-&gt;j的所有走法 - 1）） **/ for(unsigned int i = 0; i &lt; tmp.size(); i ++)&#123; path[tmp[i].first][tmp[i].second] --; if(!path[tmp[i].first][tmp[i].second])&#123; path[tmp[i].first][tmp[i].second] ++; &#125;else&#123; ans --; &#125; &#125; return ans; &#125;&#125;graph;int main()&#123;#ifdef fre freopen("AntiFloyd.in", "r", stdin); freopen("AntiFloyd.out", "w", stdout);#endif int n, x; scanf("%d", &amp;n); graph.clear(n); for(int i = 1; i &lt;= n; i ++)&#123; for(int j = 1; j &lt;= n; j ++)&#123; scanf("%d", &amp;x); if(x)&#123; graph.addEdgeOneWay(i, j); &#125; &#125; &#125; printf("%d\n", graph.getAns()); return 0;&#125; 总结：对于中档题的算法混搭还是很难写，多跟着老师和书走，对于学过的简单题能瞬间秒掉了，感觉还是很好！ 继续加油！]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>搜索</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七夕祭]]></title>
    <url>%2F2019%2F03%2F19%2F%E4%B8%83%E5%A4%95%E7%A5%AD%2F</url>
    <content type="text"><![CDATA[七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。 于是TYVJ今年举办了一次线下七夕祭。 Vani同学今年成功邀请到了cl同学陪他来共度七夕，于是他们决定去TYVJ七夕祭游玩。 TYVJ七夕祭和11区的夏祭的形式很像。 矩形的祭典会场由N排M列共计$N×M$个摊点组成。 虽然摊点种类繁多，不过cl只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。 Vani预先联系了七夕祭的负责人zhq，希望能够通过恰当地布置会场，使得各行中cl感兴趣的摊点数一样多，并且各列中cl感兴趣的摊点数也一样多。 不过zhq告诉Vani，摊点已经随意布置完毕了，如果想满足cl的要求，唯一的调整方式就是交换两个相邻的摊点。 两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。 由于zhq率领的TYVJ开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。 现在Vani想知道他的两个要求最多能满足多少个。 在此前提下，至少需要交换多少次摊点。 输入格式第一行包含三个整数$N$和$M$和$T$，$T$表示$c$l对多少个摊点感兴趣。 接下来$T$行，每行两个整数$x, y$，表示$cl$对处在第$x$行第$y$列的摊点感兴趣。 输出格式首先输出一个字符串。 如果能满足Vani的全部两个要求，输出both； 如果通过调整只能使得各行中cl感兴趣的摊点数一样多，输出row； 如果只能使各列中cl感兴趣的摊点数一样多，输出column； 如果均不能满足，输出impossible。 如果输出的字符串不是impossible， 接下来输出最小交换次数，与字符串之间用一个空格隔开。 数据范围$1≤N,M≤100000$$0≤T≤min(N×M,100000)$$1≤x≤N$$1≤y≤M$ 输入样例：123452 3 41 32 12 22 3 输出样例：1row 1 题目题解：这道题就相当于均分纸牌，但是题面有不同的地方，对于这道题，我们先考虑只有行或者只有列，那么我们可以发现，这个移动还可以是首尾互相交换的，那么我们整个数列就是一个环，对于环我们就得用其他的方法来解决了，用原来的方法肯定是行不通的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//#define fre yes#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N = 100005;int H[N], Z[N], f[N];// int hNumber, zNumber;long long clac(int a[N], int n) &#123; long long ans = 0; for (int i = 1; i &lt;= n; i++) &#123; a[i] -= a[0] / n; f[i] = f[i - 1] + a[i]; &#125; std::sort(f + 1, f + 1 + n); for (int i = 1; i &lt;= n; i++) &#123; ans += abs(f[i] - f[(n + 1) &gt;&gt; 1]); &#125; return ans;&#125;int main() &#123; static int n, m, k; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); for (int i = 1, x, y; i &lt;= k; i++) &#123; scanf("%d %d", &amp;x, &amp;y); H[x]++, Z[y]++; &#125; for (int i = 1; i &lt;= n; i++) &#123; H[0] += H[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; Z[0] += Z[i]; &#125; if(H[0] % n == 0 &amp;&amp; Z[0] % m == 0) &#123; printf("both %lld\n", clac(H, n) + clac(Z, m)); &#125; else if(H[0] % n == 0) &#123; printf("row %lld\n", clac(H, n)); &#125; else if(Z[0] % m == 0) &#123; printf("column %lld\n", clac(Z, m)); &#125; else puts("impossible"); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[货仓选址]]></title>
    <url>%2F2019%2F03%2F18%2F%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80%2F</url>
    <content type="text"><![CDATA[在一条数轴上有 $N$ 家商店，它们的坐标分别为 $A_1-A_N$。 现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。 为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。 输入格式第一行输入整数$N$。 第二行$N$个整数$A_1-A_N$。 输出格式输出一个整数，表示距离之和的最小值。 数据范围$1≤N≤100000$ 输入样例：1246 2 9 1 输出样例：112 题目题解：这道题需要用到中位数的思想 中位数有一个特别优秀的性质就是每一个点到中位数的距离，都是满足全局的最优性，而不是局部最优性 于是我们可以得到代码： 12345678910111213141516171819202122232425//#define fre yes#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N = 100005;int g[N];int main() &#123; static int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;g[i]); &#125; std::sort(g + 1, g + 1 + n); int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; ans += abs(g[i] - g[(n + 1) / 2]); //为什么是(n+1)/2而不是n/2 //你可以自己带一个奇数和偶数试试（我们都是向下取整） &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电影]]></title>
    <url>%2F2019%2F03%2F18%2F%E7%94%B5%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[莫斯科正在举办一个大型国际会议，有$n$个来自不同国家的科学家参会。 每个科学家都只懂得一种语言。 为了方便起见，我们把世界上的所有语言用$1$到$10^9$之间的整数编号。 在会议结束后，所有的科学家决定一起去看场电影放松一下。 他们去的电影院里一共有$m$部电影正在上映，每部电影的语音和字幕都采用不同的语言。 对于观影的科学家来说，如果能听懂电影的语音，他就会很开心；如果能看懂字幕，他就会比较开心；如果全都不懂，他就会不开心。 现在科学家们决定大家看同一场电影。 请你帮忙选择一部电影，可以让观影很开心的人最多。 如果有多部电影满足条件，则在这些电影中挑选观影比较开心的人最多的那一部。 输入格式第一行输入一个整数$n$，代表科学家的数量。 第二行输入$n$个整数$a_1,a_2…a_n$,其中$a_i$表示第$i$个科学家懂得的语言的编号。 第三行输入一个整数$m$，代表电影的数量。 第四行输入$m$个整数$b_1,b_2…b_m$,其中$b_i$表示第$i$部电影的语音采用的语言的编号。 第五行输入$m$个整数$c_1,c_2…c_m$,其中$c_i$表示第$i$部电影的字幕采用的语言的编号。 请注意对于同一部电影来说，$b_i≠c_i$。 同一行内数字用空格隔开。 输出格式输出一个整数，代表最终选择的电影的编号。 如果答案不唯一，输出任意一个均可。 数据范围$1≤n,m≤200000$,$1≤a_i,b_i,c_i≤10^9$ 输入样例：1234532 3 223 22 3 输出样例：12 题目题解：这道题的思想很好懂，给你$N$个人懂的语言，再给你$M$个电影的语音和字幕，假如我们没有字幕，我们仅考虑语音，那么我们用计数排序搞一次就好了，然后再遍历一次看看谁最多即可。但此时有个字幕，也很好解决，记录答案的时候顺便记录一下当前的看得懂字幕人数就好了，如果我们的语音人数相同，那么就看 看得懂字幕人数哪个多。 但是，本题的语言的编号范围是 $10^9$ 对于$64MB$的空间我们的数组只能开到 $10^6$，那应该怎么办呢？ 使用离散化 我们可以看到 $N$的范围是$2×10^5$，这很显然 能够让我们进行离散化 详细的过程，看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//#define fre yes#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N = 200005;int a[N], b[N], c[N];int arr[N * 3], num[N * 3], sum[N * 3]; //我们要一个数组塞三个数组进去int tnt, tot;void discret() &#123; std::sort(arr + 1, arr + 1 + tnt); //先排序 for (int i = 1; i &lt;= tnt; i++) &#123; if(arr[i] != arr[i - 1] || i == 1) &#123; num[++tot] = arr[i]; //给每一种数离散（重新编号） &#125; &#125;&#125;int query(int x) &#123; return std::lower_bound(num + 1, num + 1 + tot, x) - num; //二分查找我们需要的值在离散化中变成了什么&#125;int main() &#123; static int n, m; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); arr[++tnt] = a[i]; //将数塞到离散化的数组里 &#125; scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d", &amp;b[i]); arr[++tnt] = b[i]; //将数塞到离散化的数组里 &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d", &amp;c[i]); arr[++tnt] = c[i]; //将数塞到离散化的数组里 &#125; discret(); //进行离散化 for (int i = 1; i &lt;= n; i++) &#123; int id = query(a[i]); sum[id]++; &#125; int maxx = -1, maxy = -1, ans = 0; for (int i = 1; i &lt;= m; i++) &#123; int x = query(b[i]); int y = query(c[i]); if(sum[x] &gt; maxx) &#123; //如果有更好看的电影 maxx = sum[x], maxy = sum[y]; //记录看得懂字幕的人 ans = i; &#125; else &#123; if(sum[x] == maxx) &#123; //如果两个电影听得懂的人数相同 if(sum[y] &gt; maxy) &#123; //比较两个电影看得懂字幕的人 maxx = sum[x], maxy = sum[y]; ans = i; &#125; &#125; &#125; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特殊排序]]></title>
    <url>%2F2019%2F03%2F15%2F%E7%89%B9%E6%AE%8A%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[有$N$个元素，编号$1.2..N$，每一对元素之间的大小关系是确定的，关系不具有传递性。 也就是说，元素的大小关系是$N$个点与$N*(N-1)/2$条有向边构成的任意有向图。 然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过10000次提问来获取信息，每次提问只能了解某两个元素之间的关系。 现在请你把这$N$个元素排成一行，使得每个元素都小于右边与它相邻的元素。 你可以通过我们预设的bool函数compare来获得两个元素之间的大小关系。 例如，编号为a和b的两个元素，如果元素a小于元素b,则compare（a,b）返回true，否则返回false。 将N个元素排好序后，把他们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。 数据范围$1≤N≤1000$ 输入样例1[[0, 1, 0], [0, 0, 0], [1, 1, 0]] 输出样例1[3, 1, 2] 注意：不存在两个元素大小相等的情况。 题目题解这道题搞不太懂那个输入样例是什么鬼东西..，不过不需要那个输入样例我们也能够解决这道题，因为有OJ提供的compare函数，可以提供两个数的大小关系 这道题想着用二分解决的话，得判断一下询问次数会不会超过10000次，因为循环中嵌了一个compare函数，所以询问次数就是$Nlogn$ 大概在9000次左右，完全足够让我们通过这道题。 这里我们使用插入排序，因为时间复杂度和询问次数是不冲突的，所以我们可以用插入排序很快的解决这个问题。 详细看代码。 123456789101112131415161718192021222324252627// Forward declaration of compare API.// bool compare(int a, int b);// return bool means whether a is less than b.class Solution &#123;public: vector&lt;int&gt; specialSort(int N) &#123; vector&lt;int&gt; res; //储存我们的答案 res.push_back(1); //第一个数 for (int i = 2; i &lt;= N; i++) &#123; //开始插入♂ int l = 0, r = res.size() - 1; // while(l &lt; r) &#123; //二分过程 int mid = (l + r + 1) &gt;&gt; 1; if(compare(res[mid], i)) l = mid; r = mid - l; //找到应该插入的位置 &#125; res.push_back(i); for (int j = res.size() - 2; j &gt; r; j--) swap(res[j], res[j + 1]); //我们这里从0开始存的数 所以应该是从res.size - 1开始 但因为//我们又要交换 res[j], res[j + 1]的位置 所以这里是res.size - 2 if(compare(i, res[r])) swap(res[r], res[r + 1]); //最后到位置之后判断一下 i 和 res[r]的大小关系 //这里是个边界条件 如果所有的数都比当前这个数大的话 那么就进行以上操作 &#125; return res; //返回答案 结束 &#125;&#125;; 解决方法回忆图 【锯齿图】]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最佳牛围栏]]></title>
    <url>%2F2019%2F03%2F13%2F%E6%9C%80%E4%BD%B3%E7%89%9B%E5%9B%B4%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[农夫约翰的农场由 $N$ 块田地组成，每块地里都有一定数量的牛,其数量不会少于1头，也不会超过2000头。 约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。 围起区域内至少需要包含 $F$ 块地，其中 $F$ 会在输入中给出。 在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。 输入格式第一行输入整数 $N$ 和 $F$ ，数据间用空格隔开。 接下来 $N$ 行，每行输出一个整数，第$i+1$行输出的整数代表，第$i$片区域内包含的牛的数目。 输出格式输出一个整数，表示围起区域内每块地包含的牛的数量的平均值可能的最大值乘以1000得到的数值。 数据范围$1≤N≤100000$$1≤F≤N$ 输入样例：123456789101110 66 4210385941 输出样例：16500 题目题解先分析这道题应该用什么算法，本题应该怎么入手 首先本题没有出现二分的特征词：“最大值最小” or “最小值最大” 并且给的数列不具备单调性，并且不适于排序，我们看到这种题可以先提出假设 比如，假设这道题用二分能解出 那么我们判断是否存在一个平均值大于等于mid，如果最优解是x，那么mid &lt;= x的时候，必然可以找到一段，其平均值≥mid， 否则 一定找不到 对于二分，二分是二分性而不是单调性 只要满足可以找到一个值一半满足一半不满足即可 而不用满足单调性 那么这个题我们就可以使用二分来解决 知道了这道题的算法之后，我们就来分析这道题 首先我们二分针对的是平均数，那么根据我们就可以捏出以下主函数 123456789101112131415int main() &#123; scanf("%d %d", &amp;n, &amp;m); double l = 0, r = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;cows[i]); r = std::max(r, (double)cows[i]); &#125; //最小左区间 最大右区间 while(r - l &gt; 1e-5) &#123; //开始二分 因为是实数所以这里还搞个精度 double mid = (l + r) / 2; // 不是&gt;&gt;1 这里是实数 if(check(mid)) l = mid; //将问题转变为判定问题 else r = mid; &#125; printf("%d\n", (int)(r * 1000)); //因为我们找的极大值 所以要右端点*1000 否则可能会出错 return 0; &#125; 二分最难的地方就在于check函数的写法，我们先来捋一遍思路，防止写代码的时候思路混乱 ①：我们要找的是 有没有一段不小于F的区间，使这段区间的平均数尽可能的大，如果我们找到了一段连续的区间且区间长度不小于F且平均数大于我们二分的平均数 那么大于这个数且区间也满足的一定满足了 我们直接判断正确即可 ②：因为我们要找一段区间的平均数，根据平均数的一个基本应用，显而易见，对于一段序列，每个数减去我们所算的平均数，如果大于0 那么他本身就大于平均数，如果小于0 那么它本身就小于平均数 此时我们就能算出哪些数大于0 哪些数小于0 ，之后我们再使用前缀和，就能判断一个区间内的平均值是否大于或小于我们二分的平均数了 ③：据②我们还可以继续优化，因为我们不仅需要找F大小区间内，我们还要找＞F大小区间内的，我们如果用二次for太费时间了，我们这里可以使用双指针的做法，我们设$i = 0, j = F$ 每次使两个数++ [$i++, j++$] 因为$i, j$始终满足相距$F$的距离，所以我们用一个变量$minv$来存储$i$所遍历到的最小值，这样我们比较的距离一定是$≥F$的，并且如果我们用$j$位的前缀和数减去$minv$的话，就能得到我们的最优解，如果这个最优解＞= 0 那么就满足我们的指定条件（如果不懂这一步 请看②）。 到此，结束 我们便可以写出二分的$check$代码 1234567891011bool check(double avg) &#123; for (int i = 1; i &lt;= n; i++) &#123; sum[i] = sum[i - 1] + (cows[i] - avg); //计算前缀和 &#125; double minv = 0; //设置最小值 for (int i = 0, j = m; j &lt;= n; j++, i++) &#123; minv = std::min(minv, sum[i]); //找最优极小值 if(sum[j] - minv &gt;= 0) return true; //进行判断 &#125; return false; //如果所有的都不满足，那么这个平均数就一定不满足&#125; 以下是全代码： 12345678910111213141516171819202122232425262728293031323334353637//#define fre yes#include &lt;cstdio&gt;#include &lt;iostream&gt;const int N = 100005;int cows[N]; double sum[N];int n, m;bool check(double avg) &#123; for (int i = 1; i &lt;= n; i++) &#123; sum[i] = sum[i - 1] + cows[i] - avg; &#125; double minv = 0; for (int i = 0, j = m; j &lt;= n; j++, i++) &#123; minv = std::min(minv, sum[i]); if(sum[j] - minv &gt;= 0) return true; &#125; return false;&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;m); double l = 0, r = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;cows[i]); r = std::max(r, (double)cows[i]); &#125; while(r - l &gt; 1e-5) &#123; double mid = (l + r) / 2; if(check(mid)) l = mid; else r = mid; &#125; printf("%d\n", (int)(r * 1000)); return 0; &#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最高的牛]]></title>
    <url>%2F2019%2F03%2F13%2F%E6%9C%80%E9%AB%98%E7%9A%84%E7%89%9B%2F</url>
    <content type="text"><![CDATA[有 $N$ 头牛站成一行，被编队为1、2、3…N，每头牛的身高都为整数。 当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。 现在，我们只知道其中最高的牛是第 $P$ 头，它的身高是 $H$ ，剩余牛的身高未知。 但是，我们还知道这群牛之中存在着 $M$ 对关系，每对关系都指明了某两头牛 $A$ 和 $B$ 可以相互看见。 求每头牛的身高的最大可能值是多少。 输入格式第一行输入整数$N,P,H,M$，数据用空格隔开。 接下来M行，每行输出两个整数 $A$ 和 $B$ ，代表牛 $A$ 和牛 $B$ 可以相互看见，数据用空格隔开。 输出格式一共输出 $N$ 行数据，每行输出一个整数。 第 $i$ 行输出的整数代表第 $i$ 头牛可能的最大身高。 数据范围$1≤N≤10000$,$1≤H≤1000000$,$1≤A,B≤10000$,$0≤M≤10000$ 输入样例：1234569 3 5 51 35 34 33 79 8 输出样例：123456789545344555 注意： 此题中给出的关系对可能存在重复 题目题解：如果题目难度一直这么简单就好了… 这道题就是一道简单的差分，但是因为可能会出现重复情况，并且B可能会比A还要大，此时我们交换一下位置就OK了其他的就是简单的差分处理，详细看代码。 12345678910111213141516171819202122232425262728293031//#define fre yes#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;const int N = 500005;int a[N], b[N];std::map&lt;int, int&gt; V;int main() &#123; static int N, M, H, P; scanf("%d %d %d %d", &amp;N, &amp;P, &amp;H, &amp;M); for (int i = 1, x, y; i &lt;= M; i++) &#123; scanf("%d %d", &amp;x, &amp;y); if(x &gt; y) std::swap(x, y); if(V[x] == y) continue; //用map判断 V[x] = y; //记录 b[x + 1] -= 1; //差分 下同 b[y] += 1; &#125; for (int i = 1; i &lt;= N; i++) &#123; a[i] = a[i - 1] + b[i]; //算出当前位置不加H的情况的长度 &#125; for (int i = 1; i &lt;= N; i++) &#123; printf("%d\n", a[i] + H); //加上H的情况的长度 &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IncDec序列]]></title>
    <url>%2F2019%2F03%2F07%2FIncDec%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[给定一个长度为 $n$ 的数列 $a_1,a_2,…,a_n$，每次可以选择一个区间 $[l,r]$，使下标在这个区间内的数都加一或者都减一。 求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。 输入格式第一行输入正整数$n$。 接下来$n$行，每行输入一个整数，第i+1行的整数代表$a_i$。 输出格式第一行输出最少操作次数。 第二行输出最终能得到多少种结果。 数据范围$0&lt;n≤10^5$,$0≤a_i&lt;2147483648$ 输入样例：1234541122 输出样例：1212 题目题解差分题：根据题目是使用区间加减一，很容易联想到差分 思路如下 ①：我们先算出整个数列的差分，因为不会用到原数组，所以可以用原数组进行差分 ②：差分的使用方法是 比如区间$[i, k] + 1$就是$f_i + 1, f_{k + 1} - 1$ 所以对于一组差分数列，我们尽量选择负数加正数减 这样能保证我们在还存在正负数的情况下是最少次数 ③：我们如果正数 + 负数 ≠ 0 那么一定有数余下，我们只需要让剩下的数和一号位或者$n + 1$号位进行操作就好了，因为这两个位置对于我们的结果不会造成干扰，既然这样，我们就有两个位置可以供选择 于是求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。这个问题就能解决了 在保证②满足的情况下，我们剩下的方案一定有.. 例如我们剩下5，就有 [0 5] [1 4] [2 3] [3 2] [4 1] [5 0] 一共六种（这里的[x y] x就是和一号位操作的数量 y就是和n + 1号位操作的数量）。于是结论就是满足③开始的情况下再+1即可解决 12345678910111213141516171819202122232425262728293031//#define fre yes#include &lt;cstdio&gt;#include &lt;iostream&gt;typedef long long LL;const int N = 100005;int a[N];int main() &#123; static int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); &#125; for (int i = n; i &gt;= 2; i++) &#123; a[i] = a[i] - a[i - 1]; //差分 &#125; LL pos = 0, meg = 0; for (int i = 2; i &lt;= n; i++) &#123; if(a[i] &gt; 0) pos += a[i]; //加所有正数 else meg -= a[i]; //所有负数 &#125; printf("%lld\n", std::min(meg, pos) + abs(meg - pos)); //最少操作次数 printf("%lld\n", abs(pos - meg) + 1); //最终得到的种类数 return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>差分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[激光炸弹]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[一种新型的激光炸弹，可以摧毁一个边长为 $R$ 的正方形内的所有的目标。 现在地图上有 $N$ 个目标，用整数$X_i,Y_i$表示目标在地图上的位置，每个目标都有一个价值$W_i$。 激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个边长为 $R$ 的正方形的边必须和$x，y$轴平行。 若目标位于爆破正方形的边上，该目标不会被摧毁。 求一颗炸弹最多能炸掉地图上总价值为多少的目标。 输入格式第一行输入正整数 $N$ 和 $R$ ,分别代表地图上的目标数目和正方形的边长，数据用空格隔开。 接下来$N$行，每行输入一组数据，每组数据包括三个整数$X_i,Y_i,W_i$,分别代表目标的$x$坐标，$y$坐标和价值，数据用空格隔开。 输出格式输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。 数据范围$0&lt;N≤10000$$0≤X_i,Y_i≤5000$ 输入样例：1232 10 0 11 1 1 输出样例：11 题目题解：此题知道一个概念：前缀和 普通一维前缀和 $f[k] = \sum _{i = 1}^{k}f[i]$ 那么二维前缀和如何求呢？ 请看图片 如果我们要求右下角的点的前缀和，我们就用 整个大矩形 - 两个红矩形 + 一个蓝矩形 即 $f_{i,j} = f_{i, j} - f_{i - R, j} - f_{i, j - R} + f_{i - R, j - R}$ 然后就能算我们的答案了。 记住，这里的爆炸矩形的边角所取的点可以不在整个大矩形上，也可以在大矩形中的小矩形内。 123456789101112131415161718192021222324252627282930313233//#define fre yes#include &lt;cstdio&gt;#include &lt;iostream&gt;const int N = 5005;int g[N][N];int main() &#123; static int N, R; scanf("%d %d", &amp;N, &amp;R); int n = R, m = R; for (int i = 0, x, y, w; i &lt; N; i++) &#123; scanf("%d %d %d", &amp;x, &amp;y, &amp;w); x ++, y ++; g[x][y] += w; n = std::max(n, x), m = std::max(m, y); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; g[i][j] += g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1]; &#125; &#125; int res = 0; for (int i = R; i &lt;= n; i++) &#123; for (int j = R; j &lt;= m; j++) &#123; res = std::max(res, g[i][j] - g[i - R][j] - g[i][j - R] + g[i - R][j - R]); &#125; &#125; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二维前缀和</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分形之城]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%88%86%E5%BD%A2%E4%B9%8B%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[城市的规划在城市建设中是个大问题。 不幸的是，很多城市在开始建设的时候并没有很好的规划，城市规模扩大之后规划不合理的问题就开始显现。 而这座名为 Fractal 的城市设想了这样的一个规划方案，如下图所示： 当城区规模扩大之后，Fractal 的解决方案是把和原来城区结构一样的区域按照图中的方式建设在城市周围，提升城市的等级。 对于任意等级的城市，我们把正方形街区从左上角开始按照道路标号。 虽然这个方案很烂，Fractal 规划部门的人员还是想知道，如果城市发展到了等级 N，编号为 A 和 B 的两个街区的直线距离是多少。 街区的距离指的是街区的中心点之间的距离，每个街区都是边长为 10 米的正方形。 输入格式第一行输入正整数$n$，表示测试数据的数目。 以下$n$行，输入n组测试数据，每组一行。 每组数据包括三个整数 $N,A,B$ 表示城市等级以及两个街区的编号，整数之间用空格隔开。 输出格式一共输出nn行数据，每行对应一组测试数据的输出结果，结果四舍五入到整数。 数据范围$1≤N≤31$$1≤A,B≤2^{2N},$ $1≤n≤1000$ 输入样例：12343 1 1 2 2 16 1 3 4 33 输出样例：12310 30 50 题目题解：题目有点难度，我们先将A, B所代表的坐标表示出来，这样我们就直接用两点间的距离公式将A, B的直线距离算出来。 那么如何求出两个坐标呢？ 首先先观察这个图形的变化吧，我们先定义，一个大正方形 = 4 中正方形 = 4 （每个中正方形的小正方形），我们又可以得出，每个小正方的数目都是相同的。于是4个中正方形也是相同的，为了方便，我们称一个大正方形为$P$ 一个中正方形为$R$。 我们由上边的结论求出$R$的边长，即$2^{n - 1}$，由此我们可以得到一个中正方形中有多少个小正方形 即 $2^{2(n - 1)}$ （这里的$n$为城市等级） 定义完毕后，我们就回归主题 图形的变化 首先是我们解决的方式是 以大化小 将一个大等级化成若干个小等级来解决问题，首先我们先得到最小的图形，然后根据图形的规律将其拼出更大的图形，那么首先我们得得到我们的目标点的位置，然后就逐渐缩小目标，这样就可以得到目标点是由最初点（Lv.1）的哪个点旋转得来的，那么我们就可以通过坐标旋转完善图形来找到我们的坐标，这个过程可以通过递归完成。 关于坐标旋转，可以通过以下公式，这个公式的意义是 使一个坐标顺时针旋转$\theta$角，这里是坐标！ (x,y) \cdot \begin{bmatrix} cos\theta & sin\theta\\ -sin\theta & cos\theta \end{bmatrix}因为我们旋转的都是所有大图形的左上角的中图形（除了Lv.1） 所以除了第一个图形，我们都需要经过移动而不仅仅是旋转。 接下来就是细节处理了，首先是我们坐标编号，我们从0开始编号，为了方便处理坐标处于哪个中方块。 对于坐标，我们给一个大方块的左上角的中方块记号为0， 右上角为1， 右下角为2，左下角为3。这个记号有什么用呢？我们可以通过题目给的$m$来推出它的起始点的编号是什么，那么我们用$m$除对于当前大方块中的中方块中的小方块的总数量，我们就能得到当前点处于的哪个中方块中，此时记号就能起到作用了。 然后我们就能算出两个坐标，用两点之间的距离公式就能算出答案了。 123456789101112131415161718192021222324252627282930313233//#define fre yes#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;typedef long long LL;typedef std::pair&lt;LL, LL&gt; PLL;PLL calc(LL n, LL m) &#123; if(n == 0) return &#123;0, 0&#125;; LL len = 1ll &lt;&lt; n - 1, cnt = 1ll &lt;&lt; 2 * n - 2; //len = 每个中方块的边长 cnt = 每个中方块内小方块的数量 PLL pos = calc(n - 1, m % cnt); //以大化小 LL x = pos.first, y = pos.second; LL z = m / cnt; //计算对于每个等级在哪个中方块内 if(z == 0) return &#123;y, x&#125;; //这里看不懂的记住我之前说的话 旋转是针对坐标！ if(z == 1) return &#123;x, y + len&#125;; //我们的图像可以理解为以横为y,以竖为x 这样画图就能理解 if(z == 2) return &#123;x + len, y + len&#125;; //同上 if(z == 3) return &#123;2 * len - 1 - y, len - 1 - x&#125;; //同z = 0的情况&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; LL N, A, B; scanf("%ld %ld %ld", &amp;N, &amp;A, &amp;B); PLL ac = calc(N, A - 1); PLL bc = calc(N, B - 1); double x = ac.first - bc.first, y = ac.second - bc.second; printf("%.0lf\n", sqrt(x * x + y * y) * 10); //记住这里要0lf(四舍五入到整数） &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约数之和]]></title>
    <url>%2F2019%2F02%2F23%2F%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[假设现在有两个自然数A和B，S是$A^B$的所有约数之和。 请你求出S mod 9901的值是多少。 输入格式在一行中输入用空格隔开的两个整数A和B。 输出格式输出一个整数，代表S mod 9901的值。 数据范围$0≤A,B≤5×10^7$ 输入样例：12 3 输出样例：115 注意: A和B不会同时为0。 题目题解：这个题需要三个新知识： 质因数分解任何一个数 $x$ 都能分解为 $x = $$\prod ^k_{i=1}{p_i}^{a_i}$ 约数个数定理那么根据质因数分解的数，我们就可以得到总的约数个数为 $f(n) = $$\prod ^{k}_{i=1}(a_i + 1)$，那么根据这样，我们就可以得到约数的个数的数量 很好证明，因为$p^n$的约数有$p^0, p^1, p^2, … , p^n$ 即个数为$(n + 1)$ 约数定理$n$的$\prod ^n_{i=1}(a_i + 1)$个正约数的和为： $\prod ^k_{i = 1}\sum ^k_{j = 0}(p^j_i) $ 因为这样算复杂度太高，我们需要将式子简单化一下。 对于这道题，约数定理就有 $A^B$ 的约数和为： $\prod ^k_{i = 1}\sum ^{k×B}_{j = 0}(p^j_i) $ 定义sum(n, k)为$p^0 + p^1 + … + p^k$，分为两部分的和为 $(p ^ 0 + … + p^{\frac{k}{2}}) + (p ^ {\frac{k}{2} + 1} + … + p ^ k)$ 右边的式子可以提一个公因数 $p^{\frac{k}{2}} + 1$ 于是就变成了 $(p ^ 0 + … + p ^ {\frac{k}{2}}) × (p ^ {\frac{k}{2}} + 1)$ 于是就得到了sum(n, \frac{k}{2}) × (p ^ {\frac{k}{2}} + 1) 于是我们只用算后面的式子，前面有递归解决即可 这里需要注意，我们只有偶数次方能这么算，如果是奇数次方，我们将一个n暴力算出来，然后再用上面的方法算即可 12345678910111213141516171819202122232425262728293031323334353637383940//#define fre yes#include &lt;cstdio&gt;const int MOD = 9901;int qmi(int a, int k) &#123; a %= MOD; int res = 1; while(k) &#123; if(k &amp; 1) res = res * a % MOD; a = a * a % MOD; k &gt;&gt;= 1; &#125; return res;&#125;int sum(int p, int k) &#123; if(k == 0) return 1; if(!(k &amp; 1)) return (p % MOD * sum(p, k - 1) + 1) % MOD; return (1 + qmi(p, k / 2 + 1)) * sum(p, k / 2) % MOD;&#125;int main() &#123; static int A, B; scanf("%d %d", &amp;A, &amp;B); int res = 1; for (int i = 2; i &lt;= A; i++) &#123; int s = 0; while(A % i == 0) &#123; s++; A /= i; &#125; if(s) res = res * sum(i, s * B) % MOD; &#125; if(!A) res = 0; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想要发泄一下]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%83%B3%E8%A6%81%E5%8F%91%E6%B3%84%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[2019.2.20 实力终究是硬伤，不管是文化成绩还是竞赛成绩 搞了两年竞赛，动态规划都不会 搞了两年文化课，次次进最后一个班 迷茫和混沌充斥了我整个高中。 现在，清晰了。但我也失去了我本应能得到的一切。 有实力的人终究是有实力的，即使是颓废每天也可以看成让我一步。 一年前的约定，我还记得。希望我能完成自己的约定，这也是对一个人的约定。 北大，等我。]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇怪的汉诺塔]]></title>
    <url>%2F2019%2F02%2F20%2F%E5%A5%87%E6%80%AA%E7%9A%84%E6%B1%89%E8%AF%BA%E5%A1%94%2F</url>
    <content type="text"><![CDATA[汉诺塔问题，条件如下： 1、这里有A、B、C和D四座塔。 2、这里有n个圆盘，n的数量是恒定的。 3、每个圆盘的尺寸都不相同。 4、所有的圆盘在开始时都堆叠在塔A上，且圆盘尺寸从塔顶到塔底逐渐增大。 5、我们需要将所有的圆盘都从塔A转移到塔D上。 6、每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。 请你求出将所有圆盘从塔A移动到塔D，所需的最小移动次数是多少。 汉诺塔塔参考模型 输入格式没有输入 输出格式对于每一个整数n($1≤n≤12$),输出一个满足条件的最小移动次数，每个结果占一行。 输入样例：1没有输入 输出样例：1参考输出格式 题目题解经典的递推题，我们设d为三个塔的情况，f为四个塔的情况。 我们d的推导公式是 $d_i = d_{i - 1} * 2 + 1$ 推导方式：若当前我们有三个塔，第一个塔有5个，我们将上面的4个移动到第二个需要花费K次移动的话，那么我们再将最大的一个移动最后一个，我们再将第二个叠到第三个 需要花费K + 1次移动，总共就是K*2 + 1次移动。 因为每次我们的n都是累加的，所以我们可以反复利用d数组 分析完三个塔，我们再来分析四个塔 推导方式：若当前我们有四个塔，那么移动总数一定小于三个塔，因为多了一个塔，我们可以将之前第二个塔的盘子的数量减少，这减少的部分就直接移动到最后一个塔，而第三个塔的盘子仍旧放到第四个塔不动， 然后这样到最后的结果一定变少。（自己画图理解一下）那么推导公式是 $f_i = min(f_i, f_j + d_{i - j})$ 这里的$j$就是枚举的分出去的量，这个量可能 $=0$ 但永远不可能$≥i$ 为什么是$d_{i - j}$，因为将上面的移动完之后，下面的只用移动一次到最后一个塔就行。 于是我们就可以得到代码： 123456789101112131415161718192021222324252627//#define fre yes#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;const int N = 15;int d[N], f[N];int main() &#123; d[1] = 1; //初始化，如果n = 1的话 移动次数为1 for (int i = 2; i &lt;= 12; i++) &#123; d[i] = d[i - 1] * 2 + 1; //转移方程 &#125; memset(f, 0x3f, sizeof(f)); //因为求最小值，所以讲数组重定为最大 f[0] = 0; //n为0时，f为0 for (int i = 1; i &lt;= 12; i++) &#123; //12次n for (int j = 0; j &lt; i; j++) &#123; //枚举j 分几个走 f[i] = std::min(f[i], f[j] * 2 + d[i - j]); //转移方程 &#125; &#125; for (int i = 1; i &lt;= 12; i++) &#123; printf("%d\n", f[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费解的开关]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3%2F</url>
    <content type="text"><![CDATA[你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态 123451011101101101111000011011 在改变了最左上角的灯的状态后将变成： 123450111111101101111000011011 再改变它正中间的灯后状态将变成： 123450111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。 输入格式第一行输入正整数$n$，代表数据中共有$n$个待解决的游戏初始状态。 以下若干行数据分为$n$组，每组数据有$5$行，每行$5$个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。 输出格式一共输出$n$行数据，每行有一个小于等于$6$的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。 对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。 数据范围$0&lt;n≤500$ 输入样例：1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 输出样例：12332-1 题目题解对于这个题，其实在2017年有一道初赛题和这个很像 对于这个题，我们如果考虑第一行的所有情况，就相当于确定了整个棋盘的所有情况 因为一个数如果想要改变，并且不会修改之前修改的情况的话，一定是修改当前数的下一行的同列数。 那么我们只需枚举第一行的所有情况即可。 那么根据第一行的枚举情况我们向下推就好。 详细看代码注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//#define fre yes#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;const int N = 15;char path[N][N];const int INF = 1e9;int dx[] = &#123;0, -1, 0, 1, 0&#125;; //向4个方向移动int dy[] = &#123;0, 0, 1, 0, -1&#125;;void turn(int x, int y) &#123; for (int i = 0; i &lt; 5; i++) &#123; int a = x + dx[i], b = y + dy[i]; if(a &gt;= 0 &amp;&amp; a &lt; 5 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 5) &#123; path[a][b] ^= 1; //这里的意思是将path[a][b]换成ASCII上的二进制数然后异或完之后再换回去 这样'1' ^ 1 = '0' '0' ^ 1 = '1' &#125; &#125;&#125;int work() &#123; int ans = INF; for (int k = 0; k &lt; 1 &lt;&lt; 5; k++) &#123; //枚举第一排的所有情况 用二进制数表示 char backup[N][N]; int res = 0; memcpy(backup, path, sizeof path); //复制整个path数组到backup for (int j = 0; j &lt; 5; j++) &#123; //枚举第一排的所有情况 if(k &gt;&gt; j &amp; 1) &#123; res++; turn(0, j); &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; if(path[i][j] == '0') &#123; res++; turn(i + 1, j); &#125; &#125; &#125; bool is_successful = true; for (int j = 0; j &lt; 5; j++) &#123; if(path[4][j] == '0') &#123; is_successful = false; break; &#125; &#125; if(is_successful) ans = std::min(ans, res); mempcpy(path, backup, sizeof backup); //将path替换到backup &#125; if(ans &gt; 6) ans = -1; //记得步数不能超过6 return ans;&#125;int main() &#123; static int T; scanf("%d", &amp;T); while(T--) &#123; for (int i = 0; i &lt; 5; i++) scanf("%s", path[i]); printf("%d\n", work()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归实现排列型枚举]]></title>
    <url>%2F2019%2F02%2F18%2F%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[把 $1~n$ 这 $n$ 个整数排成一行后随机打乱顺序，输出所有可能的次序。 输入格式一个整数$n$。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。 数据范围$1≤n≤9$ 输入样例：13 输出样例：1234561 2 31 3 22 1 32 3 13 1 23 2 1 题目题解相比于递归实现指数型枚举与递归实现组合型枚举，这道题需要输出次序，因为我们的二进制只能表示某一位是否用过，并不能储存位置，所以我们需要使用数组的帮助。 详细看代码 123456789101112131415161718192021222324252627282930//#define fre yes#include &lt;cstdio&gt;#include &lt;vector&gt;int n;std::vector&lt;int&gt; path; //vector数组void dfs(int u, int state) &#123; if(u == n) &#123; for (int i = 0; i &lt; path.size(); i++) &#123; printf("%d ", path[i]); &#125; puts(""); return ; &#125; for (int i = 0; i &lt; n; i++) &#123; if(!(state &gt;&gt; i &amp; 1)) &#123; path.push_back(i + 1); dfs(u + 1, state | (1 &lt;&lt; i)); //不需要讨论不选，因为所有数必须选 path.pop_back(); //递归回来记得清理足迹 &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;n); dfs(0, 0); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归实现组合型枚举]]></title>
    <url>%2F2019%2F02%2F18%2F%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[从 $1~n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。 输入格式两个整数 $n,m$ ,在同一行用空格隔开。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。 数据范围$n&gt;0$,$0≤m≤n$ ,$n+(n−m)≤25$ 输入样例：15 3 输出样例：123456789101 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5 题目题解相比于递归实现指数型枚举这道题多了一个数量限制，我们仅仅只需要将代码改一改就好了 12345678910111213141516171819202122232425262728//#define fre yes#include &lt;cstdio&gt;int n, m;void dfs(int u, int sum, int state) &#123; if(sum + n - u &lt; m) return ; //增加一个优化 （这里可以删除） if(sum == m) &#123; for (int i = 0; i &lt; n; i++) &#123; if(state &gt;&gt; i &amp; 1) &#123; printf("%d ", i + 1); &#125; &#125; puts(""); return ; &#125; if(u == n) return ; dfs(u + 1, sum + 1, state | (1 &lt;&lt; u)); //因为我们要从小到大 所以我们要先选 dfs(u + 1, sum, state); //或者不选&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;m); dfs(0, 0, 0); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归实现指数型枚举]]></title>
    <url>%2F2019%2F02%2F18%2F%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。 输入格式输入一个整数$n$。 输出格式每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。 数据范围$1≤n≤15$ 输入样例：13 输出样例：1234567322 311 31 21 2 3 题目题解递归基础模板题 详细看代码 12345678910111213141516171819202122232425//#define fre yes#include &lt;cstdio&gt;int n;void dfs(int u, int state) &#123; //第一个表示搜到第几了，第二个表示一个二进制数表示 哪些数用过 if(u == n) &#123; //如果遍历到第n个数了那么我们就输出即可 for (int i = 0; i &lt; n; i++) &#123; if(state &gt;&gt; i &amp; 1) &#123; //第i个数如果用过， printf("%d ", i + 1); //输出i &#125; &#125; puts(""); return ; &#125; dfs(u + 1, state); //不选第u个数 dfs(u + 1, state | 1 &lt;&lt; u);//选第u个数&#125;int main() &#123; scanf("%d", &amp;n); dfs(0, 0); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短Hamilton路径]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[给定一张 $n$ 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。 输入格式第一行输入整数$n$。 接下来$n$行每行$n$个整数，其中第$i$行第$j$个整数表示点$i$到$j$的距离（记为a[i,j]）。 对于任意的$x,y,z$，数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]&gt;=a[x,z]。 输出格式输出一个整数，表示最短Hamilton路径的长度。 数据范围$1≤n≤20$$0≤a[i,j]≤10^7$ 输入样例：12345650 2 4 5 12 0 6 5 34 6 0 8 35 5 8 0 51 3 3 5 0 输出样例：118 题目题解Hamilton路径是一种经典的NP问题，这种问题没有一个有效的多项式进行优化 所以我们可以考虑爆搜，并使用位运算进行计算优化 首先，如果使用爆搜，我们就得遍历所有的可能 这个时间复杂度是 O(20!) 那么就是 2432902008176640000 这么多的时间复杂度 所以我们可以排除爆搜这种做法，那么我们就考虑其他的想法 因为我们要走完所有的路，并且走最短路 我们考虑两种走法 （若此时我们有 $i$ $j$ $k$ 三个点 1：$i$ ——&gt; $j$ 2：$i$ ——&gt; $k$ ——&gt; $j$ 若第二种的路径长度小于第一种，说明我们走下面是最优的，我们 i -&gt; j 的长度就可以变成最优的那个 于是我们就可以推出关系式 $f_{i,j} = min(f_{i,j}, f_{i - (1 &lt;&lt; j),k} + weight_{k,j})$ 这里的 $i$ 储存的是我们所有点的状态（二进制数），$j$ 表达的是第 $j$ 个点 $k$ 表达的是第 $k$ 个点 （$i$如果是 7[111] 那么 就表示第一、二、三个点都是用过的） 这里的 $i - (1 &lt;&lt; j)$ 就是当前状态是由上一个第$j$个点没有遍历过的状态转移过来的 于是根据上方关系，我们就可以列出代码 12345678910111213141516171819202122232425262728293031323334353637//#define fre yes#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;const int N = 1 &lt;&lt; 20, M = 25;int f[N][M], weight[M][M];int main() &#123; static int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; scanf("%d", &amp;weight[i][j]); &#125; &#125; memset(f, 0x3f, sizeof(f)); //因为求最小值，我们需要先将路程转为最大值 f[1][0] = 0; for (int i = 0; i &lt; 1 &lt;&lt; n; i++) &#123; //枚举所有状态 for (int j = 0; j &lt; n; j++) &#123; //枚举所有点 if(i &gt;&gt; j &amp; 1) &#123; //如果第j个点遍历过了 for (int k = 0; k &lt; n; k++) &#123; //枚举第k个点 if(i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) &#123; //如果在状态中减去j之后第k个点依旧遍历到了 f[i][j] = std::min(f[i][j], f[i - (1 &lt;&lt; j)][k] + weight[k][j]); //进行转移方程 &#125; &#125; &#125; &#125; &#125; printf("%d\n", f[(1 &lt;&lt; n) - 1][n - 1]); //因为我们是从0开始记位，所以我们都要-1 return 0;&#125; 注意 这里的$f_{i,j}$并不是代表的 $i$ 点到 $j$ 点，而是当前已经到达 $j$ 点时所有点的状态，以及当前走过的最短路径！！]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[64位整数乘法]]></title>
    <url>%2F2019%2F02%2F17%2F64%E4%BD%8D%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[求 $a$ 乘 $b$ 对 $p$ 取模的值。 输入格式第一行输入整数$a$，第二行输入整数$b$，第三行输入整数$p$。 输出格式输出一个整数，表示$a*b Mod p$的值。 数据范围$1≤a,b,p≤10^{18}$ 输入样例：13 4 5 输出样例：12 题目题解推导式子等同于 快速幂 只需稍微修改即可，详细看代码 12345678910111213141516//#define fre yes#include &lt;cstdio&gt;int main() &#123; long long a, b, c; scanf("%lld %lld %lld", &amp;a, &amp;b, &amp;c); long long res = 0; while(b) &#123; if(b &amp; 1) res = (res + a) % c; a = (a + a) % c; b &gt;&gt;= 1; &#125; printf("%lld\n", res); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[求 $a$ 的 $b$ 次方对 $p$ 取模的值。 输入格式三个整数 $a,b,p$ ,在同一行用空格隔开。 输出格式输出一个整数，表示a^b mod p的值。 数据范围$1≤a,b,p≤10^9$ 输入样例：13 2 7 输出样例：12 题目题解若要直接算 $a^b$ 即计算 $b$ 遍，复杂度就是 $O(n)$ 快速幂的时间复杂度可以将原本 $O(n)$ 的时间复杂度缩短为 $O(logn)$ 基本思想： 原式若为 $a^{10}$ 那么 原式 = $a ^ {((2 × 1) + (2 × 3))}$ = $a ^ {(2 × 1)} + a ^ {(2 × 3)}$ 为什么将 10 分为关于 2 的式子？ 因为可以将其联系到二进制数 根据二进制数我们可以利用二进数的特点将其的计算量大幅度减少 于是我们可以得出以下代码… 123456789101112131415//#define fre yes#include &lt;cstdio&gt;int main() &#123; static int a, b, p; scanf("%d %d %d", &amp;a, &amp;b, &amp;p); int res = 1 % p; //若 b = 0 p = 1 那么下面计算就不会进行 最后结果不会计算 所以需要%一个 while(b) &#123; if(b &amp; 1) res = (long long)res * a % p; // 中途数据会超long long这里需要转换 a = (long long)a * a % p; b &gt;&gt;= 1; &#125; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[2019年2月12日，你好，世界！]]></content>
  </entry>
</search>
